var server = 'http://localhost:3000/data';
var s = new sigma('graph-container')
var buildUrl = (url, param = 0) => `${url}?degree=${param}`
var currentData = null;
var arrayOfCategories = ['cat1', 'cat2', 'cat3', 'cat4', 'cat5', 'cat6', 'cat7'] 

var domAddOptions = (target) => {
    $('#' + target).append(`<option selected>All categories</option>`)
        arrayOfCategories.forEach((el, i) => {
            $('#' + target).append(`<option value=${el}>${el}</option>`)
        })
}

// apply one filter
var filterBycategory = (obj, param) => {
    return new Promise((resolve, reject) => {
        var filteredNodes = obj.nodes.filter(el => {
            return el.thisNodeBelongsToTheseCategories.indexOf(param) > -1
        });
        var discardedNodesIds = obj.nodes.filter(el => el.thisNodeBelongsToTheseCategories.indexOf(param) === -1).map(el => el.id);
        var filteredEdges = obj.edges.filter(el => {
            return discardedNodesIds.indexOf(el.target) === -1 & discardedNodesIds.indexOf(el.source) === -1 
        });
        resolve({ edges: filteredEdges, nodes: filteredNodes })
    })
}

// fetch data and parse it
var fetchData = e => {
    var url = (e === undefined)? buildUrl(server, 0) : buildUrl(server, e.target.value);
    return fetch(url)              // makes request to server
        .then(data => data.json())  // parses the json
        .then(data => {currentData = data; return data}) //store current data
        .then(data => { populateOptions(data); return data} ) //populete panels

};

//populate panel 
var populateOptions = data => {
    document.querySelectorAll('select').forEach(el => {
        $('#' + el.id).find('option').remove().end()
            domAddOptions(el.id)
    })
}

// updates global sigmaJS instance
var render = (data) => { 
    s.graph.clear();
    s.graph.read(data);
    s.refresh();
    s.refresh();
}

//event listeners
$('document').ready(() => {
    fetchData()
        .then(render)
})

$('#min-degree').change((e) => {
    fetchData(e)
        .then(render)
})

$('#node-category')
.change(e => {
    filterBycategory(currentData, e.target.value)      
        .then(filteredData => render(filteredData))
})

